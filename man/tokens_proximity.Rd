% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/proximity.R
\name{tokens_proximity}
\alias{tokens_proximity}
\title{Extract Proximity Information}
\usage{
tokens_proximity(
  x,
  pattern,
  get_min = TRUE,
  valuetype = c("glob", "regex", "fixed"),
  case_insensitive = TRUE,
  count_from = 1,
  tolower = TRUE,
  keep_acronyms = FALSE
)
}
\arguments{
\item{x}{a \code{tokens} or \code{tokens_with_proximity} object.}

\item{pattern}{pattern for selecting keywords, see \link[quanteda:pattern]{quanteda::pattern} for details.}

\item{get_min}{logical, whether to return only the minimum distance or raw distance information; it is more relevant when \code{keywords} have more than one word. See details.}

\item{valuetype}{See \link[quanteda:valuetype]{quanteda::valuetype}.}

\item{case_insensitive}{logical, see \link[quanteda:valuetype]{quanteda::valuetype}.}

\item{count_from}{numeric, how proximity is counted from when \code{get_min} is \code{TRUE}. The keyword is assigned with this proximity. Default to 1 (not zero) to prevent division by 0 with the default behaviour of \code{\link[=dfm.tokens_with_proximity]{dfm.tokens_with_proximity()}}.}

\item{tolower}{logical, convert all features to lowercase.}

\item{keep_acronyms}{logical, if \code{TRUE}, do not lowercase any all-uppercase words. See \code{\link[quanteda:tokens_tolower]{quanteda::tokens_tolower()}}.}
}
\value{
a \code{tokens_with_proximity} object. It is similar to \code{\link[quanteda:tokens]{quanteda::tokens()}}, but only \code{\link[=dfm.tokens_with_proximity]{dfm.tokens_with_proximity()}}, \code{\link[quanteda:convert]{quanteda::convert()}}, \code{\link[quanteda:docvars]{quanteda::docvars()}}, and \code{\link[quanteda:meta]{quanteda::meta()}} methods are available. A \code{tokens_with_proximity} has a modified \code{\link[=print]{print()}} method. Also, additional data slots are included
\itemize{
\item a document variable \code{proximity}
\item metadata slots for all arguments used
}
}
\description{
This function extracts distance information from a \code{\link[quanteda:tokens]{quanteda::tokens()}} object.
}
\details{
Proximity is measured by the number of tokens away from the keyword. Given a tokenized sentence: ["I", "eat", "this", "apple"] and suppose "eat" is the keyword. The vector of minimum proximity for each word from "eat" is [2, 1, 2, 3], if \code{count_from} is 1. In another case: ["I", "wash", "and", "eat", "this", "apple"] and ["wash", "eat"] are the keywords. The minimal distance vector is [2, 1, 2, 1, 2, 3]. If \code{get_min} is \code{FALSE}, the output is a list of two vectors. For "wash", the distance vector is [1, 0, 1, 2, 3]. For "eat", [3, 2, 1, 0, 1, 2].
Please conduct all text manipulation tasks with \verb{tokens_*()} functions before calling this function. To convert the output back to a \code{tokens} object, use \code{\link[quanteda:as.tokens]{quanteda::as.tokens()}}.
}
\examples{
library(quanteda)
tok1 <- data_char_ukimmig2010 \%>\%
    tokens(remove_punct = TRUE) \%>\%
    tokens_tolower() \%>\%
    tokens_proximity(c("eu", "euro*"))
tok1 \%>\%
    dfm() \%>\%
    dfm_select(c("immig*", "migr*")) \%>\%
    rowSums() \%>\%
    sort()
## compare with
data_char_ukimmig2010 \%>\%
    tokens(remove_punct = TRUE) \%>\%
    tokens_tolower() \%>\%
    dfm() \%>\%
    dfm_select(c("immig*", "migr*")) \%>\%
    rowSums() \%>\%
    sort()
## rerun to select other keywords
tok1 \%>\% tokens_proximity("britain")
}
\seealso{
\code{\link[=dfm.tokens_with_proximity]{dfm.tokens_with_proximity()}} \code{\link[quanteda:tokens]{quanteda::tokens()}}
}
